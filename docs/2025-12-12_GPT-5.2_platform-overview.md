# 2025-12-12 (GPT-5.2) — Autonomous Agents Platform: Current State Overview

## What this project is
This repo (`autonomous-agents-platform/`) is a pnpm + Turborepo monorepo that turns the “autonomous coding agent” workflow into a **web application**:

- Users create or refine an **app specification** (chat-driven or wizard-driven).
- The platform launches an **autonomous build** inside a **cloud sandbox** (currently E2B).
- The UI shows **streaming progress/logs** and saves **build artifacts** to object storage for download.

## High-level architecture (monorepo)
- **`apps/web/` (Next.js App Router)**: UI + API routes for chats/specs/projects/builds, including build monitoring over SSE.
- **`packages/agent-core/`**: agent event types, progress parsing, prompts/harness infra.
- **`packages/sandbox-providers/`**: sandbox abstraction + E2B implementation (via `@e2b/code-interpreter`).
- **`packages/database/`**: Prisma models + data helpers (users, projects, chat sessions, app specs, builds, logs, events).
- **`packages/storage/`**: S3-compatible storage abstraction (MinIO locally; S3/R2 in prod).

## Key user workflows that exist today
### 1) “Chat Builder” → generate spec → launch build
In `apps/web/src/app/(dashboard)/chat/page.tsx`, the flow is:

- **Stage 1 (Discovery)**: user chats to describe the app.
- **Stage 2 (Expansion)**: server expands description into a more complete XML-like app spec via `/api/expand-spec`.
- **Stage 3 (Review)**: user reviews the spec and launches a build via `POST /api/builds`.

Chat sessions, messages, and linked specs are persisted in the database (`ChatSession`, `AppSpec`).

### 2) “Wizard” → generate spec → launch build
In `apps/web/src/app/(dashboard)/wizard/page.tsx`, a multi-step wizard produces a spec and also launches a build via `POST /api/builds`.

### 3) Builds list / build detail / monitoring
- **List**: `apps/web/src/app/(dashboard)/builds/page.tsx` loads builds from `GET /api/builds`.
- **Detail**: `apps/web/src/app/(dashboard)/builds/[id]/page.tsx` loads build from `GET /api/builds/[id]` and renders a build monitor component.

Monitoring uses **Server-Sent Events** via `GET /api/builds/[id]/stream`.

## Current build execution pipeline (server-side)
### Build creation
`POST /api/builds`:
- Validates spec size and basic limits.
- Creates a `Build` row, sets `status=RUNNING`, sets initial progress.
- Calls `startBuildInBackground(buildId, ...)` (fire-and-forget).

### Build runner (sandbox execution + artifact saving)
In `apps/web/src/lib/sandbox/build-runner.ts`:

1. Create an E2B sandbox (if configured; otherwise simulate).
2. Run `runSandboxAgent(...)`:
   - Agent loop calls Anthropic on the server and executes tools (`bash`, `write_file`, `read_file`) inside the sandbox.
   - Writes `app_spec.txt` and expects a `feature_list.json` progression model.
   - Emits structured events (tool/file/progress/phase/etc.) for richer UI.
3. Save build artifacts:
   - Downloads `/home/user` as a tar buffer from sandbox provider.
   - Converts tar → zip in `apps/web/src/lib/sandbox/artifact-storage.ts`.
   - Uploads zip to S3-compatible storage (MinIO locally, S3/R2 in prod).
4. Destroy sandbox.
5. Mark build completed/failed with `completeBuild()` (sets `artifactKey` if saved).

### Artifact download
`GET /api/builds/[id]/download`:
- Verifies user owns the build.
- Requires `status=COMPLETED`.
- Returns either:
  - `?info=true`: JSON with artifact metadata
  - otherwise: redirects to a signed download URL (from S3-compatible storage).

## Datastore + infra helpers already present
### Build model fields hinting at future “preview”
In Prisma `Build` model:
- `sandboxId String?`
- `outputUrl String?`
- `artifactKey String?`

The current runner sets `artifactKey`, but does not yet populate `sandboxId` or `outputUrl` (see issues doc for implications).

### Local dev infra (docker-compose)
`docker-compose.yml` sets up:
- Postgres
- MinIO + bucket auto-creation (`build-artifacts`)

This aligns with `env.example` providing `S3_*` values for local storage.


