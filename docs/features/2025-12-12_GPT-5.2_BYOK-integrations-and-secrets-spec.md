# 2025-12-12 (GPT-5.2) — BYOK Integrations & Secrets: Spec + Implementation Plan

## Summary
Implement a **Bring Your Own Keys (BYOK)** system so users can connect third-party services (e.g., Supabase, Stripe) and securely provide the keys needed for a generated application. The platform should:

- Detect required integrations/secrets from the spec (and/or agent output).
- Provide a **best-in-class UX** for collecting keys.
- Securely store secrets (encrypted) with strict access control.
- Inject secrets into the build sandbox at runtime without ever writing them into artifacts.
- Validate credentials (“Test connection”) before starting builds.

**Non-goal**: platform-managed organization keys. This system is strictly BYOK.

---

## Goals
- **Correctness**: builds don’t start until required integrations are connected and validated.
- **Security**: secrets are encrypted at rest, redacted from logs, never included in artifacts.
- **Great UX**: guided “Connect” flow with provider-specific instructions, validation, and “Test connection”.
- **Reusability**: secrets can be stored at **project scope** and reused across builds; optionally overridden per build.
- **Extensibility**: adding a provider should be “catalog entry + validator + optional tester”.

## Constraints / assumptions
- Builds run in remote sandboxes (E2B currently).
- Web app is Next.js App Router with server routes and Prisma DB.
- We can add new Prisma tables/migrations.

---

## User experience (UX)

### Primary flow: Review Spec → Connect Integrations → Start Build
1. User finishes spec (Chat Builder or Wizard) and reaches **Review**.
2. UI shows an **Integrations checklist** derived from a manifest:
   - Provider cards (Supabase, Stripe, Email, Storage, etc.)
   - Status: Not connected / Connected / Invalid / Needs attention
3. User selects a provider card and sees a **guided form**:
   - Field-level descriptions
   - “Where do I find this?” help links
   - Inline validation
   - **Test connection** button
4. Once all required providers are connected + valid → **Start Build** enabled.

### Build-time behavior
- At build start, server fetches required secrets and injects them into sandbox env.
- UI clearly indicates which integrations were injected.

### Secret scopes
- **Project secrets** (default): reusable across builds in same project.
- **Build overrides** (optional later): one-off overrides for a specific build (never persisted beyond TTL if desired).

---

## Provider catalog (source of truth)
Create a provider catalog defining:
- provider id + display name
- required fields + env var mapping
- validation rules (format checks)
- “test connection” implementation (server-side)
- docs/help links

Example (conceptual):

```ts
type ProviderId = 'supabase' | 'stripe' | 'resend' | 'posthog' | 's3' | 'openai';

type ProviderField = {
  key: string;                 // canonical field id
  label: string;
  envVar: string;              // how it appears inside the sandbox
  required: boolean;
  secret: boolean;             // hide in UI, encrypt at rest, redact in logs
  placeholder?: string;
  helpUrl?: string;
  validate?: 'url' | 'jwt' | 'prefix' | 'regex';
  validateHint?: string;
};

type ProviderDefinition = {
  id: ProviderId;
  name: string;
  category: 'database' | 'auth' | 'payments' | 'email' | 'storage' | 'analytics' | 'ai';
  fields: ProviderField[];
  testConnection?: {
    // server-side test endpoint uses this to verify keys
    kind: 'http' | 'sdk' | 'sql';
  };
};
```

This catalog prevents the agent/spec from requesting arbitrary secrets.

---

## Integration manifest (how we “discern what keys are needed”)
Add a manifest object derived from:

1) **Spec parse** (deterministic): detect mentions like `<database>supabase</database>` or “use Stripe”.
2) **Agent-declared manifest** (optional but recommended): require the agent to output a machine-readable list early, e.g. `integrations.json`.
3) **User confirmation**: UI shows detected providers and lets user add/remove integrations (with guardrails).

### Manifest schema (recommended)
- `providers[]`: list of provider ids + required/optional + purpose
- `env[]`: resolved env vars needed in sandbox

---

## Security requirements
- **Encryption at rest**:
  - Store secrets encrypted using a server-side key (e.g., `SECRETS_ENCRYPTION_KEY`).
  - Use authenticated encryption (AES-256-GCM).
- **Access control**:
  - Only the owning user (or team members later) can read/write secrets.
  - Never return raw secrets to the browser except at time of entry; thereafter show masked.
- **Redaction**:
  - Redact secret values from all logs/events (server logs, build logs, tool output).
  - Avoid printing env var dumps or config objects.
- **Artifact hygiene**:
  - Ensure `.env*` files are not written into artifacts by the agent; lint/check at the end of build.
- **Least privilege**:
  - Prefer public keys where possible; avoid requiring admin/service-role keys unless explicitly needed.

---

## Data model (Prisma)
Add tables to store provider connections and encrypted secrets.

### Minimal tables
- `IntegrationConnection`
  - `id`
  - `userId`
  - `projectId` (nullable if you want “global per user” later)
  - `provider` (enum/string)
  - `status` (`CONNECTED` | `INVALID` | `PENDING`)
  - `lastValidatedAt`
  - `createdAt`, `updatedAt`
- `IntegrationSecret`
  - `id`
  - `connectionId`
  - `key` (canonical field id or env var)
  - `encryptedValue` (bytes/base64 string)
  - `metadata` (json; non-sensitive)
  - `createdAt`, `updatedAt`

### Build linkage (optional, but useful)
Add `Build.integrations` JSON snapshot at build start (provider ids + env var names), so builds are reproducible without storing secrets in the build record.

---

## API endpoints (Next.js routes)

### Catalog
- `GET /api/integrations/catalog`
  - returns provider definitions (safe metadata only)

### Connections
- `GET /api/projects/[id]/integrations`
  - list connections + status (no secrets)
- `POST /api/projects/[id]/integrations/[provider]`
  - create/update connection fields (accept secrets; store encrypted)
- `POST /api/projects/[id]/integrations/[provider]/test`
  - server-side validation (“Test connection”)
- `DELETE /api/projects/[id]/integrations/[provider]`
  - disconnect + delete secrets

### Build gating
- `POST /api/builds`
  - before starting build:
    - compute manifest from spec
    - verify required connections exist + validated recently
    - if missing: return a structured error `{ missingIntegrations: [...] }`

---

## Build runner integration (injecting BYOK into the sandbox)
At build start (server-side), compute env vars for required providers from encrypted storage:

- Create `env: Record<string, string>` containing ONLY:
  - required keys for providers used by this build
  - any non-secret config values the app needs
- Pass env into sandbox creation (E2B provider supports `envs`).

**Rule**: the agent should prefer reading env vars at runtime; never write `.env` into the repo.

---

## Provider list (prioritized by “most common”)
### Phase 1 (most common, highest leverage)
- **Supabase** (DB + Auth)
  - fields: `SUPABASE_URL`, `SUPABASE_ANON_KEY` (and optional `SUPABASE_SERVICE_ROLE_KEY` only if required)
  - test: call `GET {SUPABASE_URL}/rest/v1/` with anon key (or a lightweight endpoint)
- **Stripe** (payments)
  - fields: `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET` (optional), `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY`
  - test: Stripe SDK list customers (limited) or retrieve account
- **Resend** (email) or **SendGrid** (pick one first)
  - field: `RESEND_API_KEY` (or SendGrid key)
  - test: validate key with provider API

### Phase 2 (common)
- **Postgres connection string** (external DB)
  - field: `DATABASE_URL`
  - test: attempt connection
- **S3-compatible storage** (uploads)
  - fields: `S3_ENDPOINT` (optional), `S3_REGION`, `S3_ACCESS_KEY_ID`, `S3_SECRET_ACCESS_KEY`, `S3_BUCKET_NAME`
  - test: head bucket / list prefix
- **PostHog** / **Plausible** (analytics)
  - fields: `POSTHOG_KEY`, `POSTHOG_HOST` etc.

### Phase 3 (advanced / optional)
- **OpenAI** / other model providers (if app spec requests them)
- **Clerk** / Auth0 (if user wants external auth)
- **Google OAuth** credentials (if building social login)

---

## Implementation plan (phased)

### Phase 0 — Foundations (1–2 days)
- Add `docs/features/...` spec (this file).
- Add `SECRETS_ENCRYPTION_KEY` to env example and ensure it’s required for storing secrets.
- Create provider catalog module in `apps/web/src/lib/integrations/catalog.ts`.

### Phase 1 — Data model + basic UI forms (2–4 days)
- Add Prisma models + migrations for integration connections/secrets.
- Build UI:
  - Integrations checklist component
  - Provider form component (masked inputs, help links)
  - “Save” and “Test connection”
- Add API routes for CRUD + test.

### Phase 2 — Build gating + sandbox injection (2–4 days)
- Add manifest computation from spec (simple parser + keywords + XML tags).
- Update `POST /api/builds` to enforce: required integrations connected and validated.
- Inject env vars into sandbox creation for builds.
- Add log redaction layer (server-side) for known secret values and known secret env var names.

### Phase 3 — Agent contract + manifest hardening (2–5 days)
- Require agent to emit `integrations.json` early (optional but improves detection).
- Add server-side validation: only providers/env vars in catalog can be requested.
- Add UI confirmation step: “We detected these integrations—confirm”.

### Phase 4 — Polish + safety (ongoing)
- Secret rotation UX, “last validated” display, re-test reminders.
- Per-build overrides + expiration (optional).
- Team sharing / RBAC (future SaaS).

---

## Acceptance criteria
- Dashboard/Build flows can show “Integrations required” before build start.
- A user can connect Supabase/Stripe keys and **test** them successfully.
- Builds fail fast with a clear error if keys are missing/invalid.
- Secrets are encrypted at rest and never appear in logs, events, or artifact zips.
- Sandbox receives env vars and generated app reads from env (no `.env` committed/written).


