# 2025-12-12 (GPT-5.2) — Proposal: “View Build” via Sandbox Preview Sessions

## Problem statement
Today, the platform’s “output” path is primarily:
- save artifacts to object storage (`artifactKey`)
- let users download a zip (`/api/builds/[id]/download`)

Desired next step: let users **view and interact with the resulting project** in a sandbox (preview environment), ideally via a clickable URL in the build UI.

## What the codebase already has that points toward preview
- Prisma `Build` already includes:
  - `sandboxId String?`
  - `outputUrl String?`
  - `artifactKey String?`
- The build runner currently:
  - creates a sandbox,
  - runs the agent,
  - saves artifacts,
  - destroys the sandbox,
  - marks build complete with `artifactKey`.

So the missing piece is: **retain/restore a runnable environment** and provide a **stable URL**.

## Proposed concept: Preview Sessions
Introduce the concept of a **Preview Session** per build (at least for completed builds, optionally for “live” builds too).

- **Goal**: a user can click **Open Preview** and see their built app running in a sandbox at a URL.
- **Constraints**:
  - Sandboxes must remain isolated per-user/build.
  - Previews need timeouts/quotas to avoid runaway spend.
  - URLs must be access-controlled (or short-lived + user-scoped).

### Minimal viable preview UX
- On build detail page:
  - “Download ZIP” (existing)
  - “Open Preview” (new)
  - “Stop Preview” (new, if running)
- Preview lifecycle:
  - Start preview (provision sandbox, prepare files, run server, expose URL)
  - Show URL + status
  - Auto-expire after TTL (e.g., 30–60 minutes)

## Architecture options (ordered by “likely fit”)

### Option A (recommended): Keep the build sandbox alive, expose a port, store `outputUrl`
**Flow**
1. Run the agent as today.
2. At the end, detect project type and run a start command inside sandbox, e.g.:
   - Next.js: `pnpm i` (or `npm i`), then `pnpm dev -- --port 3000` OR `pnpm build && pnpm start -p 3000`
   - Vite: `pnpm dev -- --host 0.0.0.0 --port 5173`
   - Static: `npx serve -l 3000 .`
3. Use sandbox provider primitive: “expose port → URL”.
4. Persist:
   - `Build.sandboxId` (for later stop / introspection)
   - `Build.outputUrl` (the preview URL)
   - `Build.startedAt` (time-to-preview tracking)
5. Do **not** destroy sandbox until:
   - TTL reached, or
   - user clicks “Stop Preview”.

**What must change**
- Extend `Sandbox` interface to support port exposure, e.g.:
  - `getUrl(port: number): Promise<string>` (or `exposePort(port)`).
- Implement it for E2B provider.
  - Today’s wrapper doesn’t expose port/URL primitives; you likely need to:
    - switch to an E2B SDK that supports port publishing, or
    - extend the current SDK usage if it already supports ports but isn’t wrapped.

**Pros**
- Fastest to “real preview” if provider supports port exposure.
- No artifact re-hydration needed.

**Cons**
- Requires controlling long-running processes (dev server / start server).
- Must handle idle timeouts, cleanup, and runaway CPU/memory.

### Option B: Create a dedicated “preview sandbox” from saved artifacts (re-hydrate)
**Flow**
1. Build completes and artifacts are saved.
2. When user clicks “Open Preview”:
   - Create a new sandbox.
   - Download the zip from object storage.
   - Unzip into sandbox workspace.
   - Start the server and expose port → URL.

**Pros**
- Works even if build sandboxes are destroyed immediately.
- Clean separation: build ≠ preview.

**Cons**
- Requires “upload zip → sandbox” capability (not currently in `Sandbox` interface).
- May need a second artifact type optimized for preview (built output vs source).

### Option C: “Static preview” hosted from object storage (no sandbox)
If you can produce a static deployable bundle (e.g., `index.html` + assets), you can:
- upload a “preview web bundle” to S3/R2
- serve behind a signed URL or your own domain

**Pros**
- Cheapest to run, easiest to scale.

**Cons**
- Only works for static-compatible outputs; not for serverful apps.

## Data model suggestion (smallest incremental)
You already have `Build.outputUrl` and `Build.sandboxId`. Minimal additions (optional) if you want better lifecycle:
- `previewStatus` (RUNNING/STOPPED/EXPIRED)
- `previewExpiresAt`
- `previewPort`

But you can also start with just:
- populate `sandboxId` + `outputUrl` on preview start
- clear them on stop/expire

## API surface (suggested)
- `POST /api/builds/[id]/preview`
  - starts a preview, returns `{ outputUrl, sandboxId, expiresAt }`
- `GET /api/builds/[id]/preview`
  - returns current preview info + status
- `DELETE /api/builds/[id]/preview`
  - stops the preview (destroy sandbox)

## Security notes (non-negotiables for preview)
- **Authorization**: only the build owner can start/stop/see preview URL.
- **URL secrecy**: if provider URL is “public by default”, treat it as a bearer secret:
  - short TTL, rotateable, or gate behind your own proxy/auth.
- **Network policy**:
  - default deny egress (or narrow allowlist),
  - prevent lateral movement and SSRF.
- **Process supervision**:
  - enforce CPU/memory/time quotas,
  - kill runaway servers,
  - auto-expire previews.

## Suggested implementation order (practical)
1. **Add port exposure capability** to sandbox provider abstraction (interface + E2B impl).
2. Add preview API routes + DB updates (`sandboxId`, `outputUrl`, TTL).
3. Add UI: “Open Preview / Stop Preview”.
4. Add “framework detection + start command” heuristics (start small: static + Next + Vite).
5. Add safety rails: TTL, quotas, and cleanup job.


